#ifndef XRIT_UNREAL_REFLECT_H
#define XRIT_UNREAL_REFLECT_H

#include <array>
#include <cassert>
#include <cstdint>
#include <sstream>
#include <string_view>
#include <unordered_map>
#include <utility>
#include <variant>
#include <vector>

// simple reflection system for parsing and serializing json
#define REFLECT_STRUCT     // write above struct to enable reflecting this struct
#define REFLECT(Name) Name // write around the field name to enable reflecting this field
#define REFLECT_ENUM       // write above enum to enable reflection

// SFINAE helper structs
namespace xrit_unreal
{
// helper structs for SFINAE for the serialize / parse function to behave differently depending on whether we have a
// struct or an unordered map (i.e. dictionary), a vector (i.e. an array or list)
template <typename> struct IsVector : std::false_type
{
};

template <typename T> struct IsVector<std::vector<T>> : std::true_type
{
};

template <typename> struct IsUnorderedMap : std::false_type
{
};

template <typename Key, typename Value> struct IsUnorderedMap<std::unordered_map<Key, Value>> : std::true_type
{
};

template <typename T> struct IsVariant : std::false_type
{
};

template <typename... T> struct IsVariant<std::variant<T...>> : std::true_type
{
};

template <typename T>
struct IsDefault : std::bool_constant<!std::is_class_v<T> && !std::is_enum_v<T> && !IsVector<T>::value &&
                                      !IsUnorderedMap<T>::value && !IsVariant<T>::value>
{
};

// required because a vector and unordered map are also classes
template <typename T>
struct IsClass : std::bool_constant<std::is_class_v<T> && !std::is_enum_v<T> && !IsVector<T>::value &&
                                    !IsUnorderedMap<T>::value && !IsVariant<T>::value>
{
};
} // namespace xrit_unreal

//-------------------------------------------
//            Reflection Macros
//-------------------------------------------

// these macros can be automatically generated by generate_reflection.py, or manually if preferred
#define REFLECT_IMPL_ENUM_BEGIN(EnumType)                                                                              \
    template <> [[nodiscard]] auto inline xrit_unreal::enumInfo<EnumType>()                                            \
    {                                                                                                                  \
    return EnumInfoFactory<EnumType>::create(#EnumType, std::array{
#define REFLECT_IMPL_CASE(CaseName) std::string_view(#CaseName),

#define REFLECT_IMPL_ENUM_END                                                                                          \
    });                                                                                                                \
    }

#define REFLECT_IMPL_STRUCT_BEGIN(TypeName)                                                                            \
    template <> [[nodiscard]] auto inline xrit_unreal::classInfo<TypeName>()                                           \
    {                                                                                                                  \
        using TypeNameAlias = TypeName;                                                                                \
    return ClassInfoFactory<TypeName>::create(#TypeName, std::tuple{

#define REFLECT_IMPL_FIELD(FieldName) Field(#FieldName, &TypeNameAlias::FieldName),

#define REFLECT_IMPL_STRUCT_END                                                                                        \
    });                                                                                                                \
    }

// parse and serialize enum
namespace xrit_unreal
{
template <typename T, size_t Size> struct EnumInfo
{
    std::string_view name;
    std::array<std::string_view, Size> cases;
};

template <typename T> auto enumInfo()
{
}

template <typename T> struct EnumInfoFactory
{
    template <size_t Size>
    [[nodiscard]] static EnumInfo<T, Size> create(std::string_view name, std::array<std::string_view, Size> cases)
    {
        return EnumInfo<T, Size>{.name = name, .cases = cases};
    }
};

// parsing an enum from a string.
// Enum is expected to be of type unsigned int, containing one case "Invalid" and "Count" at the end
template <typename T> [[nodiscard]] T parseEnum(std::string_view string)
{
    // invalid is expected to be at index 0
    auto cases = enumInfo<T>().cases;
    for (unsigned int i = 1; i < (unsigned int)T::Count; i++)
    {
        auto s = cases[i - 1];
        if (string == s)
        {
            return (T)i;
        }
    }
    return T::Invalid;
}

template <typename T> [[nodiscard]] std::string_view serializeEnum(T value)
{
    assert(value < T::Count);
    if (value == T::Invalid)
    {
        return "Invalid";
    }
    return enumInfo<T>().cases[(unsigned int)value - 1];
}
} // namespace xrit_unreal

// logic for reflecting a struct (its type name and its fields)
namespace xrit_unreal
{
template <typename Class, typename T> struct Field
{
    std::string_view key;
    T Class::*value; // pointer to data member

    Field(std::string_view key, T Class::*value) : key(key), value(value)
    {
    }
};

// reflect struct
template <typename T, typename... Fields> struct ClassInfo
{
    std::string_view name;
    std::tuple<Fields...> fields;
};

// partial template argument deduction is not supported in c++, but as we don't want to pass the type T to the create
// function, we need a factory that provides us with the user given template argument T
template <typename T> struct ClassInfoFactory
{
    template <typename... Fields>
    [[nodiscard]] static ClassInfo<T, Fields...> create(std::string_view name, std::tuple<Fields...> fields)
    {
        return ClassInfo<T, Fields...>{.name = name, .fields = std::move(fields)};
    }
};

template <typename T> auto classInfo()
{
}

namespace internal
{
template <typename T> void buildTypeName(std::ostringstream &out)
{
    // built in type names
    if constexpr (std::is_same_v<T, std::string_view>)
    {
        out << "string";
    }
    else if constexpr (std::is_same_v<T, bool>)
    {
        out << "bool";
    }
    else if constexpr (std::is_same_v<T, int64_t>)
    {
        out << "int64";
    }
    else if constexpr (std::is_same_v<T, uint64_t>)
    {
        out << "uint64";
    }
    else if constexpr (std::is_same_v<T, float>)
    {
        out << "float";
    }
    else if constexpr (std::is_same_v<T, double>)
    {
        out << "double";
    }
    else if constexpr (IsVector<T>::value)
    {
        using ValueType = typename T::value_type;
        out << "list<";
        buildTypeName<ValueType>(out);
        out << ">";
    }
    else if constexpr (IsUnorderedMap<T>::value)
    {
        using KeyType = typename T::key_type;
        using MappedType = typename T::mapped_type;
        out << "dictionary<";
        buildTypeName<KeyType>(out);
        out << ", ";
        buildTypeName<MappedType>(out);
        out << ">";
    }
    else if constexpr (IsVariant<T>::value)
    {
        out << "variant<";
        constexpr size_t size = std::variant_size_v<T>;
        auto addVariantName = [&]<std::size_t Index>() {
            using Type = std::variant_alternative_t<Index + 1, T>;
            std::string_view variantName = classInfo<Type>().name;
            out << variantName;
            if (Index < size - 2)
            {
                out << ", ";
            }
        };
        auto iterateIndices = [&]<std::size_t... Indices>(std::index_sequence<Indices...>) {
            (addVariantName.template operator()<Indices>(), ...);
        };
        iterateIndices(std::make_index_sequence<size - 1>{}); // only iterate over after monostate
        out << ">";
    }
    else if constexpr (std::is_enum_v<T>)
    {
        out << "enum " << enumInfo<T>().name;
    }
    else if constexpr (IsClass<T>::value)
    {
        out << "class " << classInfo<T>().name;
    }
}

template <typename T> [[nodiscard]] std::string buildTypeName()
{
    std::ostringstream out;
    internal::buildTypeName<T>(out);
    return out.str();
}
} // namespace internal

template <typename T> [[nodiscard]] std::string_view typeName()
{
    static std::string typeName = internal::buildTypeName<T>();
    return typeName;
}
} // namespace xrit_unreal

#endif // XRIT_UNREAL_REFLECT_H